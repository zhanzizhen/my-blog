## 六大原则

设计模式基于六大原则：

* 开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。
* 单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。
* 里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。
* 依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。
* 迪米特法则：又名「最少知道原则」，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。
* 接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。

开闭原则是编程中最基础、最重要的设计原则。

它的意思是，对修改关闭，对拓展开放。为什么要对修改关闭？因为这样子的话，就算增加新的功能，旧的代码也不需要改动，不用去测试它，同时也保证了程序的稳定性。另外，它提高了代码的可维护性和可复用性，因为它容易被拓展。

怎么实现开闭原则？
就是做需求的时候，如果预感到后面会有类似这样的需求，那么就可以使用开闭原则。把这类需求中的规律抽象出来，写成一个公用的模块，将需求间的差异点交给接口（比如函数参数）去区别。

如果预感到后面不会再有这类需求或者类似功能的模块，那么就不需要抽象（也就是不需要使用开闭原则），毕竟抽象会带来额外的工作量。


---

https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)

---
## 用type来设计一个组件

封装一个公用组件的时候，经常会碰到有时地方大致样式或功能都一样，但又有些区别。
比如

![image](https://user-images.githubusercontent.com/22932241/92083259-56abe680-edf8-11ea-9fdb-7b987f7b6d66.png)
和下面的区别
![image](https://user-images.githubusercontent.com/22932241/92083287-64fa0280-edf8-11ea-82fe-37ac4f368e0f.png)
。
以前我的做法通常是把这个面板拆开，拆成许多可复用的小组件，让使用方去拼接。
这样是可以达到复用相同部分，但缺点是使用方的使用该组件的步骤变复杂了。而且，拼接的顺序和位置本身也是一种可复用的逻辑。

一个很好用的方法是，用type值来区别，让该公用组件根据type，自动去拼接组件。使用方不关心内部逻辑，只要用type就可以啦，舒服得很。

适用场景：业务有明显的类型区别时，就可以使用这种方法。
不适用场景：业务没有明显的类型划分，比如antd-select的 allowClear、showSearch等api，这些就不适合用type来区别。


## 享元模式
享元模式体现的是 程序可复用 的特点，为了节约宝贵的内存，程序应该尽可能地复用，就像《极限编程》作者 Kent 在书里说到的那样：Don't repeat yourself. 简单来说 享元模式就是共享对象，提高复用性。

所以说，复用代码也能节约内存，同时减少编译的代码量。


## 观察者模式（事件驱动）
事件驱动架构可以最大程度减少耦合度，因此是现代化分布式应用架构的理想之选。

事件驱动架构采用松散耦合方式，因为事件发起者并不知道哪个事件使用者在监听事件，而且事件也不知道其所产生的后续结果。



